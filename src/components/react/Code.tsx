import type {
	BuiltinLanguage,
	LanguageRegistration,
	SpecialLanguage,
	ThemeRegistration,
	ThemeRegistrationRaw,
} from 'shiki';
import { bundledLanguages, type BundledLanguage } from 'shiki/langs';
import { getCachedHighlighter } from 'node_modules/astro/dist/core/shiki.js';
import type { HTMLAttributes } from 'astro/types';
import type { ShikiHighlighter, ThemePresets } from 'node_modules/astro/node_modules/@astrojs/markdown-remark';
import { Fragment, useEffect, useState } from 'react';

interface Props extends Omit<HTMLAttributes<'pre'>, 'lang'> {
	/** The code to highlight. Required. */
	code: string;
	/**
	 * The language of your code.
	 * Supports all languages listed here: https://shiki.style/languages
	 * Instructions for loading a custom language: https://shiki.style/guide/load-lang
	 *
	 * @default "plaintext"
	 */
	lang?: BuiltinLanguage | SpecialLanguage | LanguageRegistration;
	/**
	 * The styling theme.
	 * Supports all themes listed here: https://shiki.style/themes
	 * Instructions for loading a custom theme: https://shiki.style/guide/load-theme
	 *
	 * @default "github-dark"
	 */
	theme?: ThemePresets | ThemeRegistration | ThemeRegistrationRaw;
	/**
	 * Multiple themes to style with -- alternative to "theme" option.
	 * Supports all themes found above; see https://shiki.style/guide/dual-themes for more information.
	 */
	themes?: Record<string, ThemePresets | ThemeRegistration | ThemeRegistrationRaw>;
	/**
	 * Enable word wrapping.
	 *  - true: enabled.
	 *  - false: disabled.
	 *  - null: All overflow styling removed. Code will overflow the element by default.
	 *
	 * @default false
	 */
	wrap?: boolean | null;
	/**
	 * Generate inline code element only, without the pre element wrapper.
	 *
	 * @default false
	 */
	inline?: boolean;
}


const Code = ({
		code, lang = "plaintext", theme = "github-dark", themes = {}, 
		wrap = false, inline = false, ...rest
	}: Props) => {
	const [highlighter, setHighlighter] = useState<ShikiHighlighter | null>(null);
	// shiki 1.0 compat
	if (typeof lang === 'object') {
		// `id` renamed to `name` (always override)
		// biome-ignore lint: code pulled from astro source
		if ((lang as any).id) {
		// biome-ignore lint: code pulled from astro source
			lang.name = (lang as any).id;
		}
		// `grammar` flattened to lang itself
		// biome-ignore lint: code pulled from astro source
		if ((lang as any).grammar) {
		// biome-ignore lint: code pulled from astro source
			Object.assign(lang, (lang as any).grammar);
		}
	}

	// biome-ignore lint/correctness/useExhaustiveDependencies: initial useEffect doesn't need to watch for deps
	useEffect(() => {
		const getHighlighter = async () => {
			const highlighter = await getCachedHighlighter({
				langs: [
					(typeof lang === 'string'
						? Object.keys(bundledLanguages).includes(lang)
							? lang
							: 'plaintext' as BundledLanguage
						: lang) as unknown as LanguageRegistration,
				],
				theme,
				themes,
				wrap,
			});
			setHighlighter(highlighter);
		}
    getHighlighter()
	}, [])

	if (!highlighter) {
		return null
	}

	const html = highlighter.highlight(code, typeof lang === 'string' ? lang : lang.name, {
		inline,
		// @ts-ignore
		attributes: rest,
	});

	// biome-ignore lint: html is generated by shiki
  return <div dangerouslySetInnerHTML={{ __html: html }} />
}


