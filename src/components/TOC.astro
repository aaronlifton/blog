---
import TOCScroll from "$components/react/TOCIndicator.tsx";
import type { MarkdownHeading } from "astro";
import { Icon } from "astro-icon/components";
import { TOC as TableOfContents } from "astro-toc";

type Props = {
  headings: MarkdownHeading[];
};

const { headings } = Astro.props;

let tocItems = headings.map((heading) => ({
  depth: heading.depth,
  title: heading.text,
  url: `#${heading.slug}`,
}));

const minimumDepth = Math.min(...tocItems.map((item) => item.depth));
if (minimumDepth > 1) {
  tocItems = tocItems.map((tocItem) => ({
    ...tocItem,
    depth: tocItem.depth - 1,
  }));
}
---

<div class="hidden p-4 lg:flex lg:flex-col lg:h-full bg-slate-50">
  <div class:list={["flex", "items-center", "gap-2", "h-10", "flex-none"]}>
    <Icon name="tabler/list" class="inline relative top-[-1px]" />

    <b class="m-0">Table of contents</b>

    <div
      class="flex items-center ml-auto transition-transform duration-150 ease-in lg:hidden group-open:rotate-180"
    >
      <Icon name="tabler/chevron-down" />
    </div>
  </div>

  <nav
    data-toc-wrapper
    class:list={[
      "not-prose",
      "pt-4",
      // "h-full",
      "text-base",
      "h-auto",
      "min-h-0",
      "lg:overflow-y-auto",
      "leading-6",
      "[&_a_*]:indent-0",
      "[&_ol]:m-0",
      "[&_ol]:list-none",
      "[&_ol]:pl-4",
      "[&_ol_li]:my-4",
      "[&_ol_li[data-active]>a]:text-primary",
      "[&_ol_li[data-active]>a:first-of-type]:text-zinc-800",
      "[&_ol_li[data-active]>a:first-of-type]:text-bold",
      "[&_ol_li[data-active]]>a:text-zinc-800",
      "[&_ol_li]:relative",
      "[&_ol_li_a:hover]:bg-hover",
      "[&_ol_li_a]:block",
      // "[&_ol_li_a]:truncate",
      "[&_ol_li_a]:border-b-0",
      "[&_ol_li_a]:transition-colors",
      "[&_ol_li_a]:duration-150",
      "[&_ol_ol]:pl-8",
      "[&_ol_ol_ol]:pl-12",
      "[&_ol_ol_ol_ol]:pl-16",
      "[&_ol_li_a]:text-zinc-300",
      "[&_ol_li_a]:text-[rgb(99, 102, 241)]",
      "[&_ol_li_a]:no-underline",
      "[&_ol_li_a:hover:first-of-type]:text-zinc-800",
      "[&_ol_li[data-active]_a:hover:first-of-type]:text-zinc-800",
      "flex flex-row",
    ]}
  >
    <TOCScroll client:load />
    <TableOfContents toc={tocItems} as="number" />
  </nav>
</div>

<details
  class="flex items-center mb-2 w-full rounded-lg border lg:hidden p-[0.25rem] group px-horizontal-padding bg-slate-100 border-slate-200 [&::marker]:hidden [&::webkit-details-marker]:hidden"
  aria-label="Table of contents"
>
  <summary class="list-none">
    <div class="flex gap-2 items-center align-center">
      <Icon name="tabler/list" />

      <p class="m-0 not-prose text-[15px] translate-y-[1px]">
        Table of contents
      </p>

      <div
        class="flex items-center ml-auto transition-transform duration-150 ease-in lg:hidden group-open:rotate-180"
      >
        <Icon name="tabler/chevron-down" />
      </div>
    </div>
  </summary>

  <nav
    data-toc-wrapper
    class:list={[
      "mt-4",
      "[&_ol]:m-0",
      "[&_ol]:list-outside",
      "[&_ol]:px-horizontal-padding",
      "[&_ol_li:not(:first-child)]:mt-1",
      "[&_ol_li_a]:text-amethyst-400",
    ]}
  >
    <TableOfContents toc={tocItems} as="number" />
  </nav>
</details>

<div
  data-state="top"
  id="back-to-top-link"
  class="fixed left-4 bottom-4 z-50 transition-transform translate-y-[50px] data-[state=scrolled]:translate-y-0 duration-300 ease-in-out"
>
  <button
    id="back-to-top"
    class="p-2 rounded-lg shadow-lg bg-slate-100"
  >
    <Icon name="tabler/chevron-up" />
  </button>
</div>
<script>

</script>

<script>
import { activeHeading } from "$state/index";
const getHeadingsInBlogPost = (blogPost: HTMLElement) => {
  return blogPost?.querySelectorAll(
    "h1:not(#title), h2, h3:not(#admonition-title), h4, h4, h6",
  ) ?? [];
};
let headingsInBlogPost: HTMLHeadingElement[] = [];

const observeHeaders = () => {
  const toc = document.querySelector<HTMLElement>("nav[data-toc-wrapper] ol");
  const firstTocItem = toc?.querySelector("li");
  if (firstTocItem) assertBouncingBallPosition(firstTocItem);
  const blogPost = document.querySelector("[data-blog-post]") as HTMLElement;
  headingsInBlogPost = Array.from(
    getHeadingsInBlogPost(blogPost),
  ) as HTMLHeadingElement[];

  function deactivate(listItem: HTMLLIElement): void {
    listItem.parentElement?.removeAttribute("data-active");
    listItem.removeAttribute("data-active");
  }

  function deactivateAllTocItems(): void {
    toc?.querySelectorAll("li").forEach(deactivate);
  }

  const getTOCLIElement = (id: string | null) => {
    if (!id) return null;
    return document.querySelector(`nav li a[href="#${id}"]`)?.parentElement as
      | HTMLLIElement
      | null;
  };
  const activateTOCLIElement = (TOCLIElement: HTMLLIElement) => {
    TOCLIElement?.setAttribute("data-active", "true");
  };

  const firstTocItemInViewPort = () => {
    const heading = headingsInBlogPost[0];
    if (!heading) return null;
    const headingTop = heading.getBoundingClientRect().top;
    return (headingTop < window.innerHeight);
  };
  let lastActivatedTocItem = firstTocItemInViewPort()
    ? firstTocItem
    : null;

  const observer = new IntersectionObserver(entries => {
    for (const entry of entries) {
      const id = entry.target.getAttribute("id");
      if (entry.intersectionRatio > 0) {
        deactivateAllTocItems();
        const TOCLIElement = getTOCLIElement(id);
        if (TOCLIElement) {
          activeHeading.set(TOCLIElement);
          lastActivatedTocItem = TOCLIElement;
          activateTOCLIElement(TOCLIElement);
        }
        break;
      } else {
        getTOCLIElement(id)?.removeAttribute("data-active");
      }
    }
    const numActive = document.querySelectorAll(`nav li[data-active]`).length;
    if (numActive === 0 && lastActivatedTocItem) {
      activateTOCLIElement(lastActivatedTocItem);
    }
  });

  for (const headingInBlogPost of headingsInBlogPost) {
    observer.observe(headingInBlogPost);
  }
};

// TODO: Submit bug-report to Astro
const assertBouncingBallPosition = (firstTocItem: HTMLLIElement) => {
  if (!firstTocItem) return;
  if (window.scrollY > 0) return;

  const bouncingBall = document.getElementById("bouncing-ball");
  if (!bouncingBall) return;

  const firstTOCLIElementRect = firstTocItem.getBoundingClientRect();
  const bouncingBallRect = bouncingBall.getBoundingClientRect();
  const firstTOCLIElementTop = firstTOCLIElementRect.top
    + parseFloat(getComputedStyle(firstTocItem).marginTop);
  const bouncingBallTop = bouncingBallRect.top + bouncingBallRect.height / 2;

  // Normally the distance between the center of the ball and the top of the
  // first TOC element is 7.25px, so we'll go with 10px.
  //
  // If greater than 10 px difference, there is a bug caused by exiting Astro's
  // scroll-restoration code upon swap or hard reload early, so move the
  // bouncing ball to the top of the first TOC element.
  if (Math.abs(bouncingBallTop - firstTOCLIElementTop) > 5) {
    if (import.meta.env.DEV) console.log("resetting");
    bouncingBall.style.top = `${23}px`;
    activeHeading.set(firstTocItem);
  }
};

let wasSwapped = false;
document.addEventListener("astro:after-swap", () => {
  observeHeaders();
  wasSwapped = true;
});

document.addEventListener("astro:page-load", () => {
  if (!wasSwapped) {
    observeHeaders();
  }
  const backToTopLink = document.getElementById("back-to-top-link");
  window.addEventListener("scroll", function() {
    if (!backToTopLink) return;

    if (window.scrollY > 100) {
      backToTopLink.dataset.state = "scrolled";
    } else {
      backToTopLink.dataset.state = "top";
    }
  });

  backToTopLink?.addEventListener("click", function() {
    scrollToTop();
  });

  function scrollToTop() {
    window.scrollTo({
      top: 0,
      behavior: "smooth",
    });
  }
});
</script>

<style>
[data-toc-wrapper] * {
  background: linear-gradient(120deg, #ab4e19, #c99a2e);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  -webkit-box-decoration-break: clone;
}
details {
  summary::-webkit-details-marker {
    display: none;
  }
}
</style>
