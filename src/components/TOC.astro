---
import type { MarkdownHeading } from "astro";
import { Icon } from "astro-icon/components";
// @ts-ignore -  Missing declaration file
import TOCScroll from "$components/react/TOCIndicator.tsx";
import { TOC as TableOfContents } from "astro-toc";

type Props = {
  headings: MarkdownHeading[];
};

const { headings } = Astro.props;

let tocItems = headings.map((heading) => ({
  depth: heading.depth,
  title: heading.text,
  url: `#${heading.slug}`,
}));

const minimumDepth = Math.min(...tocItems.map((item) => item.depth));
if (minimumDepth > 1) {
  tocItems = tocItems.map((tocItem) => ({
    ...tocItem,
    depth: tocItem.depth - 1,
  }));
}
---

<div class="hidden p-4 lg:flex lg:flex-col lg:h-full bg-slate-50">
  <div class:list={["flex", "items-center", "gap-2", "h-10", "flex-none"]}>
    <Icon name="tabler/list" class="inline relative top-[-1px]" />

    <b class="m-0">Table of contents</b>

    <div
      class="flex items-center ml-auto transition-transform duration-150 ease-in lg:hidden group-open:rotate-180"
    >
      <Icon name="tabler/chevron-down" />
    </div>
  </div>

  <!-- <TOCProgress client:load /> -->
  <nav
    data-toc-wrapper
    class:list={[
      "not-prose",
      "pt-4",
      // "h-full",
      "h-auto",
      "min-h-0",
      "lg:overflow-y-auto",
      "leading-6",
      "[&_a_*]:indent-0",
      "[&_ol]:m-0",
      "[&_ol]:list-none",
      "[&_ol]:pl-4",
      "[&_ol_li]:my-4",
      "[&_ol_li[data-active]>a]:text-primary",
      "[&_ol_li[data-active]>a:first-of-type]:text-zinc-800",
      "[&_ol_li[data-active]>a:first-of-type]:text-bold",
      "[&_ol_li[data-active]]>a:text-zinc-800",
      "[&_ol_li]:relative",
      "[&_ol_li_a:hover]:bg-hover",
      "[&_ol_li_a]:block",
      // "[&_ol_li_a]:truncate",
      "[&_ol_li_a]:border-b-0",
      "[&_ol_li_a]:transition-colors",
      "[&_ol_li_a]:duration-150",
      "[&_ol_ol]:pl-8",
      "[&_ol_ol_ol]:pl-12",
      "[&_ol_ol_ol_ol]:pl-16",
      "[&_ol_li_a]:text-zinc-300",
      "[&_ol_li_a]:text-[rgb(99, 102, 241)]",
      "[&_ol_li_a]:no-underline",
      "[&_ol_li_a:hover:first-of-type]:text-zinc-800",
      "[&_ol_li[data-active]_a:hover:first-of-type]:text-zinc-800",
      "flex flex-row",
    ]}
  >
    <TOCScroll client:load />
    <TableOfContents toc={tocItems} as="number" />
  </nav>
</div>

<details
  class="flex items-center mb-2 w-full rounded-lg border lg:hidden p-[0.25rem] group px-horizontal-padding bg-slate-100 border-slate-200 [&::marker]:hidden [&::webkit-details-marker]:hidden"
  aria-label="Table of contents"
>
  <summary class="list-none">
    <div class="flex gap-2 items-center align-center">
      <Icon name="tabler/list" />

      <p class="m-0 not-prose text-[15px] translate-y-[1px]">
        Table of contents
      </p>

      <div
        class="flex items-center ml-auto transition-transform duration-150 ease-in lg:hidden group-open:rotate-180"
      >
        <Icon name="tabler/chevron-down" />
      </div>
    </div>
  </summary>

  <nav
    data-toc-wrapper
    class:list={[
      "mt-4",
      "[&_ol]:m-0",
      "[&_ol]:list-outside",
      "[&_ol]:px-horizontal-padding",
      "[&_ol_li:not(:first-child)]:mt-1",
      "[&_ol_li_a]:text-amethyst-400",
    ]}
  >
    <TableOfContents toc={tocItems} as="number" />
  </nav>
</details>

<div data-state="top" id="back-to-top-link"
  class="fixed left-4 bottom-4 z-50 transition-transform translate-y-[50px] data-[state=scrolled]:translate-y-0 duration-300 ease-in-out">
  <button
    id="back-to-top"
    class="p-2 rounded-lg shadow-lg bg-slate-100"
  >
    <Icon name="tabler/chevron-up" />
  </button>
<script>

</script>

<script>
import { activeHeading } from "$state/index";
const getHeadingsInBlogPost = (blogPost: HTMLElement) => {
  return blogPost?.querySelectorAll("h1, h2, h3, h4, h4, h6") ?? [];
};
const observeHeaders = () => {
  const toc = document.querySelector<HTMLElement>("nav[data-toc-wrapper] ol");

  const tocContainer = toc?.closest<HTMLElement>("[data-toc-wrapper]");
  const blogPost = document.querySelector("[data-blog-post]") as HTMLElement;
  const firstTocItem = toc?.querySelector("li");

  function activate(listItem: HTMLLIElement): void {
    if (listItem.parentElement?.parentElement?.tagName === "li") {
      listItem.parentElement.setAttribute("data-active", "");
    }
    listItem.setAttribute("data-active", "");
  }

  function deactivate(listItem: HTMLLIElement): void {
    listItem.parentElement?.removeAttribute("data-active");
    listItem.removeAttribute("data-active");
  }

  function deactivateAllTocItems(): void {
    toc?.querySelectorAll("li").forEach(deactivate);
  }

  function getTocItemByHeading(
    heading: HTMLHeadingElement,
  ): HTMLLIElement | null {
    const headingId = heading.getAttribute("id");
    const tocAnchorElem = toc?.querySelector(`li a[href="#${headingId}"]`);

    if (!tocAnchorElem) {
      return null;
    }
    return tocAnchorElem.closest("li");
  }

  // let ratios: { [key: string]: number } = {};
  // let lastMaxRatio = 0;
  const observer = new IntersectionObserver(
    (entries) => {
      // Find the heading that is most visible in the viewport.
      // const intersectionRatio = Math.max(
      //   ...entries.map((entry) => entry.intersectionRatio),
      // );

      entries.forEach((entry): void => {
        if (!tocContainer) {
          return;
        }

        const heading = entry.target;

        if (entry.isIntersecting) {
          const tocItem = getTocItemByHeading(heading as HTMLHeadingElement);

          if (!tocItem) {
            return;
          }
          console.log({ tocItem, heading });

          deactivateAllTocItems();
          activate(tocItem);
          activeHeading.set(tocItem);
          const tocContainerCoords = tocContainer.getBoundingClientRect();
          const tocItemCoords = tocItem.getBoundingClientRect();

          if (tocItem === firstTocItem) {
            tocContainer.scrollTop = 0;
            return;
          }

          // Is the item not visible because it's above the scrollable area? Then
          // make it visible by scrolling up.
          if (tocContainerCoords.top > tocItemCoords.top) {
            tocContainer.scrollTop -= tocContainerCoords.top
              - tocItemCoords.top;
            return;
          }

          if (tocItemCoords.bottom > tocContainerCoords.bottom) {
            tocContainer.scrollTop += tocItemCoords.bottom
              - tocContainerCoords.bottom;
          }
        }
      });
    },
    {
      threshold: 1,
    },
  );

  // const headingsInBlogPost =
  //   blogPost?.querySelectorAll("h1, h2, h3, h4, h4, h6") ?? [];
  const headingsInBlogPost = getHeadingsInBlogPost(blogPost);

  for (const headingInBlogPost of headingsInBlogPost) {
    observer.observe(headingInBlogPost);
  }
}
let wasSwapped = false;
document.addEventListener("astro:after-swap", () => {
  observeHeaders(); 
  wasSwapped = true;
});

document.addEventListener("astro:page-load", () => {
  if (!wasSwapped) {
    observeHeaders();
  }
  const backToTopLink = document.getElementById("back-to-top-link")
  window.addEventListener('scroll', function() {
    if (!backToTopLink) return;

    if (window.scrollY > 100) {
      backToTopLink.dataset.state = "scrolled";
    } else {
      backToTopLink.dataset.state = "top";
    }
  });

  backToTopLink?.addEventListener('click', function() {
    scrollToTop();
  });

  function scrollToTop() {
    window.scrollTo({
      top: 0,
      behavior: 'smooth'
    });
  }
});
</script>

<style>
[data-toc-wrapper] * {
  background: linear-gradient(120deg, #ab4e19, #c99a2e);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  -webkit-box-decoration-break: clone;
}
summary h2 {
  @apply m-0 text-[var(--tw-prose-body)];
}
details {
  summary::-webkit-details-marker {
    display:none;
  }
}
</style>
