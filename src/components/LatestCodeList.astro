---
import PlayPause from "$components/react/PlayPause";
import { type CodeResults, getCodesFromMdx } from "$util/markdown";
import { Code } from "astro:components";
import { type CollectionEntry, getCollection } from "astro:content";
import LatestCodeScroller from "./LatestCodeScroller.tsx";

const codeOrder = [
  "vim",
  "tsx",
  "jsx",
  "ts",
  "js",
  "typescript",
  "javascript",
  "ruby",
  "go",
  "rust",
  "lua",
  "bash",
  "json",
  "shell",
  "html",
  "css",
];

function codeSort(a: CodeResults[0], b: CodeResults[0]) {
  if (a.lang === b.lang) return 0;
  if (!a.lang) return 1;
  if (!b.lang) return -1;
  const aIndex = codeOrder.indexOf(a.lang);
  const bIndex = codeOrder.indexOf(b.lang);
  if (aIndex === -1) return 1;
  if (bIndex === -1) return -1;
  if (aIndex < bIndex) return -1;
  if (aIndex > bIndex) return 1;
  return 0;
}

const posts: CollectionEntry<"blog">[] = await getCollection("blog");
let allCodes: CodeResults = [];
const livePosts = posts.filter((post) => !post.data.draft);
for (const post of livePosts) {
  const codes = await getCodesFromMdx(post.body, { numLines: 6 });
  if (!codes) continue;

  const codesWithPost: CodeResults = codes.map((code) => ({ ...code, post }));
  allCodes = allCodes.concat(codesWithPost).filter(code => !!code.lang).sort(
    codeSort,
  );
}
---

<LatestCodeScroller client:only="react" />
<div
  class:list={[
    "codes-header flex flex-col items-baseline md:flex-row landscape:flex-col",
    "[&_~div]:portrait:translate-y-4",
  ]}
>
  <h5>Latest code</h5>
  <!-- <a href="https://github.com/aaronlifton/blog/blob/main/src/components/LatestCodeList.astro" -->
  <!--   class="text-gray-400 hover:text-gray-500 hover:underline text-[12px] decoration-1 underline-offset-auto hover:decoration-gray-500" -->
  <!--   target="_blank" >Source</a> -->
  {/* @ts-ignore */}
  <PlayPause client:load className="icon-container" />
</div>
<!-- if mobile needs more performance, use will-change-scroll -->
<div
  class="flex overflow-auto w-full h-auto codes-container snap-x snap-mandatory snap-always"
>
  {
    allCodes.map((code) => (
      <div class="code">
        <div class="flex flex-row justify-between code-header">
          <h2 class="flex pr-3 text-base font-bold grow">{code.lang}</h2>
          {
            code.post && (
              <div class="text-sm truncate">
                <a href={`/blog/${code.post.slug}`}>{code.post.data.title}</a>
              </div>
            )
          }
        </div>
        {/* @ts-ignore */}
        <Code
          code={code.text}
          lang={code.lang}
          class="code-container"
          style="font-size:13px;max-width:700px"
        />
      </div>
    ))
  }
</div>
<script>
import { isPaused, scrollLeft, scrollDone, currentIndex } from "$state/index";

const activeTransitionsEnabled = false
const initialDelay = 1750;
const intervalTime = 5000;
let eventListeners: {target: Element | null, type: string, listener: () => void }[] = []
let interval: number | null = null;

function startInterval(func: Function) {
  setTimeout(function() {
    func();
    interval = setInterval(func, intervalTime);
  }, initialDelay);
}

const onLoad = () => {
  const codesContainer = document.querySelector(
    ".codes-container",
  ) as HTMLDivElement;
  const codes: NodeListOf<HTMLDivElement> = document.querySelectorAll(
    ".codes-container .code",
  );

  if (activeTransitionsEnabled) {
    scrollDone.subscribe((sd) => {
      if (sd == true) {
        codes.forEach((code) => code.classList.remove("active"));
        codes[currentIndex.get() % codes.length].classList.add("active");
      }
    })
  }

  const scrollNext = () => {
    if (!codesContainer) return;

    if (!isPaused.get()) {
      if (currentIndex.get() >= codes.length) {
        currentIndex.set(0)
      }

      const newScrollLeft = codes[currentIndex.get()].offsetLeft
        - codesContainer.offsetLeft;
      scrollLeft.set(newScrollLeft);
      currentIndex.set(currentIndex.get() + 1);
    }
  };

  if (!interval) {
    startInterval(scrollNext);
  }

  function onManualScroll() {
    if (!isPaused.get() || !codesContainer) return;
    let minDiff = Infinity;
    let closestIndex: number | undefined;

    const containerRect = codesContainer.getBoundingClientRect();
    codes.forEach((code, index) => {
      const rect = code.getBoundingClientRect();
      const diff = Math.abs(rect.left - containerRect.left);

      if (diff < minDiff) {
        minDiff = diff;
        closestIndex = index;
      }
    });
    if (closestIndex !== undefined) currentIndex.set(closestIndex);
    if (
      codes[codes.length - 1].getBoundingClientRect().right
        <= containerRect.left + codesContainer.clientWidth
    ) {
      currentIndex.set(0)
    }
    if (currentIndex.get() >= codes.length - 1) {
      currentIndex.set(0)
    }
  }

  codesContainer?.addEventListener(
    "touchstart",
    function() {
      isPaused.set(true);
    },
    { passive: true },
  );

  const onTouchEnd = function() {
    if (!codesContainer) return;

    isPaused.set(false);
    onManualScroll();
  }
  const onTouchStart = function() {
    isPaused.set(true);
  }
  const iconContainer = document.querySelector("div[class*=_iconContainer]");

  eventListeners = [
    { target: codesContainer, type: "touchstart", listener: onTouchStart },
    { target: codesContainer, type: "touchend", listener: onTouchEnd },
    { target: codesContainer, type: "touchcancel", listener: onTouchEnd },
    { target: codesContainer, type: "mouseleave", listener: function() {
      if (!codesContainer) return;
      isPaused.set(false);
    }},
    { target: codesContainer, type: "mouseenter", listener: onTouchStart },
    { target: codesContainer, type: "scroll", listener: onManualScroll },
    { target: iconContainer, type: "click", listener: function() {
      const isPausedVal = isPaused.get();
      isPaused.set(!isPausedVal);
    }},
  ]

  eventListeners.forEach(({ target, type, listener }) => {
    target?.addEventListener(type, listener)
  })
};

document.addEventListener("astro:page-load", onLoad, { once: true});
document.addEventListener("astro:before-swap", (props) => {
  const { to } = props;

  if (to.pathname !== "/") {
    eventListeners.forEach(({ target, type, listener }) => {
      target?.removeEventListener(type, listener)
    })
    if (interval) {
      clearInterval(interval);
      interval = null
    }
  }
  if (to.pathname === "/") {
    document.addEventListener("astro:page-load", onLoad, { once: true});
  }
})
</script>

<style>
h5 {
  @apply mb-0;
}
.codes-container {
  @apply overflow-scroll scroll-smooth scrollbar-thin scrollbar-track-card-bg/0
  scrollbar-thumb-amethyst-300;
  scroll-behavior: smooth;
}
.codes-container > div {
  font-size: 0.7rem;
}
.codes-container pre.astro-code {
  @apply scrollbar-thumb-amethyst-300;
}
.code {
  @apply mx-4 min-w-[433px] max-w-[80ch] snap-start border border-gray-200 p-4
  transition-colors duration-300 ease-in-out scrollbar-thin lg:min-w-min;
}
.code-container {
  @apply scrollbar-track-card-bg/0 scrollbar-thumb-amethyst-300;
}
.code.active {
  @apply border-amethyst-400;
}
</style>
