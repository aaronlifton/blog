---
title: "Using the sawyer gem + sorbet to fetch hypermedia"
description: "Using the sawyer gem + sorbet to fetch hypermedia"
pubDate: "Apr 23 2024"
cover: ./assets/screenshots/nvim-trpc-router.png
coverAlt: "TODO"
tags: ["rails"]
draft: true
featured: true
---

Recently I found the sawyer gem, which provides a great interface on top of
Faraday for traversing [hypermedia](https://en.wikipedia.org/wiki/HATEOAS). If
you are familiar with HATEOAS, the sawyer gem allows you to take advantage of
links relations in response. This is useful for fetching data from sites like
Github.com

Here is an example of using a provider pattern in Ruby with sorbet:

First, create a file that will handle extracting data from `Sawyer::Resource`
objects.

```ruby
class GithubResource
  extend T::Sig

  class RepositoryResult < T::Struct
  end

  sig { params(repository: Sawyer::Resource).returns(Hash) }
  def self.repository(repository)
    {
      name: repository.full_name,
      branch: repository.default_branch,
      providers: { github: repository.id }
    }
  end

  sig { params(commit: Sawyer::Resource).returns(Hash) }
  def self.commit(commit)
    {
      message: commit.commit.message,
      url: commit.html_url,
      commited_at: commit.commit.author.date,
      providers: { github: commit.sha },
      author: {
        name: commit.commit.author.name,
        email: commit.commit.author.email
      }
    }
  end
end
```

`app/models/provider.rb`

```ruby
class Provider
  extend T::Helpers
  extend T::Sig

  include ActiveModel::Model
  include ActiveModel::Attributes

  Results = T.type_alias { T::Array[Hash] }
  Cursor = T.type_alias { T.nilable T.any(Integer, String) }

  abstract!

  sig { abstract.returns Results }
  def repositories; end

  sig { params(provider: T::Key).returns(T.untyped) }
  def self.[](provider)
    to_h.fetch(provider.to_sym)
  end

  private

  sig { abstract.returns T.untyped }
  def client; end

end
```

`app/models/provider/github.rb`

```ruby
class Provider
  class Github < Provider
    sig { override.params(after: Cursor).returns(Results) }
    def repositories(after: nil)
      repositories = paginate(after:) { client.repos }
      repositories.map { |repo| Mapper.repository(repo) }
    end

    sig { params(items: Results, after: Cursor).returns(T::Boolean) }
    def exhausted?(items, after:)
      next_page.blank? || items.map(&:sha).include?(after)
    end

    sig { returns T.nilable(String) }
    def next_page
     client.last_response
           .rels
           .fetch(:next, nil)&.href
    end

    sig { params(items: Results, after: Cursor).returns(Results) }
    def paginate(items: [], after: nil)
      new_items = yield
      paginated_items = items.concat(new_items)

      if exhausted?(paginated_items, after:)
        items
      else
        paginate(items: paginated_items, after:) { client.get(next_page) }
      end
  end
end


```

o
