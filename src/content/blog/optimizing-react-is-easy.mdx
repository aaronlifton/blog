---
title: "Optimizing React is Easy"
description: "Follow one simple rule to know where to apply memoization, the single most important performance utility in React."
pubDate: "Dec 19 2023"
cover: "./assets/bad-component.png"
coverAlt: "An example of a component that 'for sure' needs memoization."
tags: ["react", "performance", "optimization"]
---

React uses something called **shallow prop comparison**. It's actually *quite* easy to understand and optimize, and
everyone should be aware of this, for it is essential to react performance.

It's important to understand the dependency arrays used as the 2nd argument in hooks like `useMemo`, `useCallback`, etc. â€” they are compared with their previous versions via shallow equality checks:

```ts annotate
// psuedo-code
function propHasChanged(prev, next) {
  return Object.is(prev, next);
  //       ^
  //     [Object equality. Remember, {} !== {}.]
}
```

React compares old and new props by shallow equality; that is, it considers whether each *new* prop is **referentially equal** to the *old* prop.

This means that if props or dependencies are *not* primitive values, like **arrays**, **objects**, or **functions** (in Javascript, functions are objects too),
even if they have the same value, each time the component is re-rendered they will be considered unequal to their previous versions if they are not **memoized**.
To avoid causing extra re-renders by having non-primitive props, [simplify props or memoize props in the parent component](https://react.dev/reference/react/memo#minimizing-props-changes).

Be careful of using objects in state, or as props, as they are not primitive values. If you need to use objects, make sure to memoize them using `useMemo` or `useCallback` as necessary.

```ts annotate
function MyFC({ obj }): React.FC<{ obj: { a: number, b: number } }> { 
  const myState  = useState({a: 1, b: 2});
  return (
    <div>
      <MyComponent obj={myState} />
//                         ^
//              [myState causes re-renders]
      <div>
        <Subcomponent val={obj} />
//                          ^
//       [so does an object from props]
      </div>
    </div>
  )
}
```

For example, when you use `useMemo`, your component re-renders whenever any element of the dependency array is not shallowly equal to its previous value.
This means that React compares every prop in your component with its previous value using the `Object.is` comparison.

Therefore, all dependencies and props should be **PRIMITIVE VALUES**!
\
Rememeber, `Object.is(3, 3)` is `true`, but `Object.is({}, {})` is `false`.
