---
title: "Enforcing abstract methods with Sorbet"
description: "Enforcing abstract methods with Sorbet"
pubDate: "Apr 23 2024"
cover: ./assets/screenshots/nvim-trpc-router.png
coverAlt: "todo"
tags: ["rails"]
draft: false
featured: true
---

One pattern I've seen in Rails projects is raising an error in a subclass if
something isn't implemented. Instead, we can use Sorbet instead to add a type
constraint to the abstract method so that subclasses must also implement it.

Here's the situation:

```ruby annotate
class BaseTransaction < ApplicationRecord
  MIN_AMOUNT = 100
#    ^
#    [Dynamic constant references are unsupported https://srb.help/5001]

  def min_amount
    raise("Not implemented")
#     ^
#     [This runtime error can be replaced with a type constraint]
  end
end
```

Sorbet does not support **dynamic constant references**, so we can't reference
something like `self.class::MIN_AMOUNT` inside the method. Upon searching Github
for `path:\*.rb self:class::`, I found that it's more common to use another
method to return default value, like `default_min_amount`, which makes more
sense compared to overriding constants. Either way, nowadays we can can use
Sorbet instead.

To do so, mark a method on the parent class as abstract via the `sig{abstract}`
signature. This type signature means that all subclasses must implement the
abstract method and satisfy its return type. Of course, parameter types are also
enforcable, and special cases may call for the use of `sig{override}`.

One thing to note about overriding abstract methods is that the child class must
implement the method with at least _some_ of the same parameters and _some_ of
the same return types. This is very similiar to how types can defined as
similiar Typescript. However, I naturally thought that Sorbet would understand
unions of Enum, but apparantly it doesn't, and only supports enum subsets like
`T.Any(FooEnum:A, FooEnum:B))`. For example,

```ruby
# typed: true
class JobStatus < T::Enum
  # (2) Enum values are declared within an `enums do` block
  enums do
    Pending = new
    Running = new
    Finished = new
  end
end

class Handler
  extend T::Sig
  extend T::Helpers
  abstract!

  sig{abstract.returns(JobStatus)}
  def run
  end
end
```

_Actually_, extending an enum in Sorbet basically isn't possible. Even with
creating the following type alias:

```ruby
class RetryableJobStatusImpl < T::Enum
  # (2) Enum values are declared within an `enums do` block
  enums do
    RetriesExhaused = new
  end
end

RetryableJobStatus = T.type_alias { T.any(JobStatus, RetryableJobStatusImpl) }
```

We run into the following, unfortunate problem:

```ruby annotate
class RetryableJobHandler < Handler
  extend T::Sig
  extend T::Helpers

  sig { override.returns(RetryableJobStatus) }
  def run
    # perform_work...
    if retries_exhausted?
      # RetryableJobStatus::RetriesExhaused
      # ^
      # [Resolving constants through type aliases is unsupported (no docs)]

      RetryableJobStatusImpl::RetriesExhaused
      # ^
      # [Now the underlying implementation is visible.]
      # [There should be a way to combine enums!]
    else
      JobStatus::Pending
    end
  end

  private
  def retries_exhausted?
    false
  end
end
```

Therefore instead of extending enums in Sorbet, you must put all the enum values
into a single enum directly.
