---
title: "Neovim macros vs normal mode"
description:
  "A discussion on the benefits of using normal mode commands versus macros in
  Neovim."
pubDate: "Dec 19 2023"
cover: "./assets/macros.png"
coverAlt: "Telescope macro extension"
tags: ["neovim", "quick tips"]
---

import { Code } from "astro:components";
import macroVideo from "./assets/videos/macro.webm";
import macroVideo2 from "./assets/videos/macro2.webm";
import globalVideo from "./assets/videos/global1.webm";

<video controls="" autoplay="" loop="true">
  <source src={macroVideo} type="video/webm" />
</video>

In Neovim, which is better to use: **macros** or **normal** mode? If you
answered macros, you might be surprised by the power of normal mode and the
**execute** command when compared to managing macros with plugins. With a simple
Lua table, you can get the most out of normal mode and emulate a macro library.

<div class="hidden">
  Additionally, in this article I will show you how to make a simple macro
  manager with NUI.
</div>

The macro commands that are too complicated to be written on-the-go can be saved
in a new file, such as `config/macros.lua`. One example of a command I've saved
is one that converts traditional Typescript functions into const functions.
There's a video of this in action below.

## Why normal mode

When using normal mode you get to practice writing normal commands live while
looking at the code, rather than try to decipher a dense string of characters or
remember what you tagged a saved macro as. I would say it's better to get good
at writing normal commands with vim motions and learn to enjoy writing them
at-will, rather than spend time organizing macros. There are macro plugins that
help you organize them, but I found that editing and remembering which macro was
which was cumbersome, and no plugin seemed to match up with the plugin I
imagined in my head. If you do need a macro manager plugin, I would recommend
[telescope-macros](https://github.com/svermeulen/vim-macrobatics) though.

### Use motions

You should note that regardless of how you are recording your commands, is that
it's better to use <kbd>fFtT</kbd> and <kbd>hjkl</kbd> than <kbd>wb</kbd>, since
targeting the beginning of a word is way more recognizable in command form than
contextual word navigation. For example, it's difficult to parse the command
`hhhhhjjkkkjdw`.

I find that using custom vim motions based on Treesitter queries is a good way
to manipulate the AST of your code with normal commands; and it starts to feel
quite magical. I recommend `mini.ai` + `nvim-various-textobjs`.

When using global commands, treesitter-based motions make complicated syntax
changes easy to perform with the `f` motion.

## Global commands

One cool trick is to use a `g` _(global)_ command to make a change to every
location of a word in a file. For example, to use a normal command to upgrade
the syntax of an older Javascript file, such as from when React was still using
object-oriented syntax, we would execute the following command:

```vim
:g :g/function /execute "norm cwconst^[f(i = f{i=> "
```

Executing `:g /function /execute "norm cwconst^[f(i = ^[f{i=> ^["` will change
the function syntax to arrow function syntax for all instances of the word
`function`. Note that the `^]` symbols are special - in most terminals, these
scape codes can be inserted via <kbd>Ctrl-V</kbd> and then <kbd>Esc</kbd>. Note
how the escape codes are purple in the video.

<video controls="" autoplay="" loop="true">
  <source src={macroVideo2} type="video/webm" />
</video>

Another trick is the `:g/found/v/notfound/{cmd}` syntax &mdash; in this example,
a command is ran on lines that contain `function`, but _do not_ contain `test`.
This a potentially way to delete all your code but keep your tests, so exercise
caution when writing the normal command!

<video controls="" autoplay="" loop="true">
  <source src={globalVideo} type="video/webm" />
</video>

I also found that recording macros using a plugin often requires multiple tries,
which I found distracting. Recording macros also requires tagging the macros
with a description, which added an extra step before re-using a newly created
macro.

## Another example

In my [Wezterm] config, I wanted to see if I could replace all instead of
`a.[Wezterm method]` with `act.[Wezterm method]`. A Wezterm method is a command
available in the Wezterm action API, like `wezterm.action.SendKey` or
`wezterm.action.SplitHorizontal`. I could have used find and replace with a
regex string, like `%s/act.[A-Z+]/a.[A-Z+]/g`, but to help solve the "macros vs
normal mode" debate, I tried doing this with a normal mode command.

1. First, let's search for a regex pattern in the command line via `/`. Upon
   pressing enter, this will set the "find" register (`@\`) to the search
   string.

   ```regex
    \ a.[A-Z*]
   ```

1. Then, we can jump to each regex match via `n`:

   ```vim
   :171,$norm nlact^["
   ```

1. Result: `a.AdjustPanelSize` and `a.ActivePaneDirection` were updated to have
   a prefix of `act.` instead of `a.`, as well as any other methods that started
   with `act.`. The official wezterm documentation references `act`, and I
   prefer to not use a single letter for variable names. _Fun fact:_ with Go,
   this is actually
   [kind of acceptable](https://www.reddit.com/r/golang/comments/3aporh/why_so_many_gophers_use_single_letter_variables/).

## Improvements

It felt powerful to use the search register in a normal command with a line
range, but there are still improvements to be made to the technique. In normal
commands, it isn't the easiest to deal with the escape characters, which make
the command more difficult to read. `execute` commands are much easier to read,
since they don't require escaping keyboard input characters. They're also more
powerful, since they can chain different vim commands together. For example:

```vim
execute "159,165norm 0fc2dw"
```

This command means, if the cursor was directly below the `*` character below,
running `:execute "2,4norm fc2dw"` would move the cursor to the `c` in `config`
on line 2, and delete the word `config` on lines 2, 3, and 4.

In other words, it would change this:

```lua annotate
  * config.a = 1,
--  ^<
-- [cursor should be here]
    config.b = 2,
    config.c = 3
```

_into this:_

```lua
{a = 1,b = 2,c = 3}
```

\
In Neovim, macros are a string representation of keyboard input, which makes them
hard to parse. To add a description to a macro, a plugin is needed. This turned out
to be more tricky than I had expected, as this is a case when the most popular plugins
on Github didn't work well for me. The first result, [NeoComposer](https://github.com/ecthelionvi/NeoComposer.nvim),
made little sense to use unless you want to choose a macro from a list with no descriptions.
Macros are displayed as virtual text, and stored in registers, which I found to be
easy to overwrite with other commands. I did enjoy being able to "scroll" through
the macros in insert mode via <kbd>C-n</kbd> and <kbd>C-p</kbd> though.

<video controls="" autoplay="" loop="true">
  <source src={macroVideo} type="video/webm" />
</video>

I considered forking the project, but I had discovered several other macro
plugins. The next most popular plugin was
[Macrobatics](https://github.com/svermeulen/vim-macrobatics), which looked to be
exactly what I wanted; but I didn't enjoy the lack of a Lua API, as it's
recommended in a modern Neovim setup to stick to Lua; as Vimscript will become
deprecated over time. Additionally, I had trouble with the plugin since it
doesn't work well with the `lazy.nvim` package manager in mind. After that, I
searched Github until I found one that actually worked well â€”
[telescope-macros](https://github.com). Adding a telescope finder is a clever
and simple solution and I applaud the author, since an editable list is the only
thing needed to manage a macro library, and I find using Telescope for UI
components to be a good pattern to follow rather than reinventing the wheel.

If I have a macro assigned to the `@l` register, using `telescope-macros`, I can
apply it repeatedly via <kbd>leader->ml</kbd>: <kbd>leader->m</kbd> opens the
telescope macros list, `l` finds the macro under the `@l` register, and `<cr>`
closes the window and applies the macro.

<div class="hidden">
I felt some modifications were essential to make â€”  for instance, adding a key
binding to [[â˜† Telescope keymap]] that would close the modal and navigate to the
previewed file. Why isn't that part of telescope by default? I searched for
examples and found none other than [[ThePrimeagen]]'s telescope modifications,
and I took his `get_preview` function, which would open the buffer from the
preview window in the editor.

However, his function didn't work and I punted on the idea after trying and
failing to get AI to help. Later on, I actually found Google Duet to be the most
proficient as writing Neovim functions.

</div>
